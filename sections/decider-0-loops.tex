% !TeX root = ../bbchallenge-paper.tex
\newpage
\subsection{Loops}\label{sec:loops}
\subsubsection{Algorithm}

Let's represent the space-time diagram of a given Turing machine $\mathcal{M}$ (Section~\ref{sec:TMs}) as the partially defined function $f_\mathcal{M}$: $$f_\mathcal{M}: \N \hookrightarrow \Z \to \alphabet \cup (\text{States}\times\alphabet)$$

Such that $f_\mathcal{M}(t)$ is only defined if $\mathcal{M}$ has not halted before time $t$ and $f_\mathcal{M}(t)$ gives the tape of the machine at step $t\in\N$ with head's state information, \ie for $z\in\Z$, $f_\mathcal{M}(t)(z)$ is either the tape symbol at position $z$, or, at the head's position, the head's state together with the symbol it is reading. For convenience, we write $f$ instead of $f_\mathcal{M}$ and we will also use notation $f(t,z)$ or $f(p)$ with $p \in \N \times \Z$ intead of $f(t)(z)$ when $f(t)$ is defined.

Let's $g_\mathcal{M}: \N \hookrightarrow \Z$, just $g$ for short, be the head's position at step $t$, when defined, \ie $f(t,g(t))$ gives the head state and read symbol at time $t$ if the machine has not halted yet. In the following, when using hypotheses involving equalities of partial functions $f$ or $g$, we also implicitly assume that the functions are defined at the points used in these hypotheses, \eg if we assume $f(x) = f(y)$ for some $x,y \in \N \times \Z$ we also implicitly assume that $f$ is defined at $x$ and $y$.


\begin{lemma}\label{lem:vector} Let $\mathcal{M}$ be a Turing machine.
    Assume there is $t_0' > t_0 \in \N$ and $l \in \N^+$ such that
    for all $0 \leq i < l$: $$f_\mathcal{M}(p_i) = f_\mathcal{M}(p'_i)$$ with $p_i = (t_0+i, g(t_0+i))$ and $p_i' = (t_0'+i, g(t_0'+i))$. Then, for all $0 \leq i < l$ we have: $ p'_i - p_i = p_0' - p_0 $.
\end{lemma}

\begin{proof}
    First note that by definition, all $p_i$ and $p_i'$ correspond to head positions. Then, because $f(p_0) = f(p'_0)$ we know that at times $t_0$ and $t_0'$ the head is in same state, reading the same symbol, hence the same transition executes and in particular both heads move in the same direction $m \in \{-1,1\}$, giving the existence of $u = (1, m)$ such that $p_1 = p_O + u$ and $p_1' = p_0' + u$. Hence, $p_1' - p_1 = p_0' + u - p_0 + u = p_0' - p_0$. Repeating the same argument for each $i$ gives $p_i' - p_i = p_0' - p_0$.
\end{proof}

\begin{definition}[Loops]\label{def:loops}
    Let $\mathcal{M}$ be a Turing machine. Let $l\in\N^+$, $t_0 \in \N$ and $p_i = (t_0+i, g(t_0+i))$ for $0 \leq i < l$. We say that $\mathcal{M}$ is a \textit{loop} of period $l$ and pre-period $t_0$ if for all $t > t_0$, $f(t,g(t)) = f(p_j)$ with $j = t-t_0 \text{ mod } t_0' - t_0$.
\end{definition}

\begin{lemma}\label{lem:loopdonthalt}
    Loops do not halt.
\end{lemma}
\begin{proof} This is immediate, by Definition~\ref{def:loops}, the space-time diagram of a loop is infinite, the machine does not halt.
\end{proof}
\newpage

\begin{figure}[h!]
    \noindent
    \begin{minipage}[t]{0.5\textwidth}
        \centering
        \scalebox{0.85}{
            \begin{tikzpicture}[every node/.style={minimum size=6mm, draw, font=\scriptsize}, scale=1]

                % Axes: Time ↓ and Space →
                \draw[->, thick] (-1.8,3.2) -- (-1.8,2.2) node[draw=none, midway, left] {\scriptsize time};
                \draw[->, thick] (-1.8,3.2) -- (-0.8,3.2) node[draw=none,midway, above] {\scriptsize space};
                % \node[draw=none] at (-1,2.7) {$p_0$};
                % \draw[-{Latex[length=1.8mm]}] (-0.8,2.6) -- (-0.4,2.3);
                \node (B0) at (0,2) {\stateBx\szero};
                \node[draw=black, draw opacity=0.6] (A1) at (0.6,1.4) {\stateAx\sone};
                \node[draw=black, draw opacity=0.6] at (1.2,0.8) {\stateCx\szero};
                \node[draw=black, draw opacity=0.6] at (0.6,0.2) {\stateDx\szero};

                \node (B0') at (0,-0.4) {\stateBx\szero};
                \node[draw=black, draw opacity=0.6] (A1') at (0.6,-1.0) {\stateAx\sone};
                \node[draw=black, draw opacity=0.6] at (1.2,-1.6) {\stateCx\szero};
                \node[draw=black, draw opacity=0.6] at (0.6,-2.2) {\stateDx\szero};

                \node[dashed] (B0'') at (0,-2.8) {{\stateBx}?};

                % Arrow and label for p_0
                \node[draw=none] at ($(B0.north west)-(0.6,-0.3)+(-0.2,0.05)$) {$p_0$};
                \draw[-{Latex[length=1.8mm]}] ($(B0.north west)-(0.6,-0.3)$) -- ($(B0.north west)-(0.05,0.00)$);

                % % Arrow and label for p_1
                % \node[draw=none] at ($(A1.north east)+(0.6,0.3)+(0.2,0.05)$) {$p_1$};
                % \draw[-{Latex[length=1.8mm]}] ($(A1.north east)+(0.6,0.3)$) -- ($(A1.north east)-(-0.05,0.00)$);

                % Arrow and label for p_0'
                \node[draw=none] at ($(B0'.north west)-(0.6,-0.3)+(-0.2,0.05)$) {$p_0'$};
                \draw[-{Latex[length=1.8mm]}] ($(B0'.north west)-(0.6,-0.3)$) -- ($(B0'.north west)-(0.05,0.00)$);

                % % Arrow and label for p_1'
                % \node[draw=none] at ($(A1'.north east)+(0.6,0.3)+(0.2,0.05)$) {$p_1'$};
                % \draw[-{Latex[length=1.8mm]}] ($(A1'.north east)+(0.6,0.3)$) -- ($(A1'.north east)-(-0.05,0.00)$);

                % Arrow and label for p_0'
                \node[draw=none] at ($(B0''.north west)-(0.6,-0.3)+(-0.2,0.05)$) {$p$};
                \draw[-{Latex[length=1.8mm]}] ($(B0''.north west)-(0.6,-0.3)$) -- ($(B0''.north west)-(0.05,0.00)$);

            \end{tikzpicture}
        }
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.5\textwidth}
        \centering
        \scalebox{0.85}{
            \begin{tikzpicture}[every node/.style={minimum size=6mm, draw, font=\scriptsize}, scale=1]



                % \node[draw=none] at (-1,2.7) {$p_0$};
                % \draw[-{Latex[length=1.8mm]}] (-0.8,2.6) -- (-0.4,2.3);
                \node (C1) at (0,2) {\stateCx\sone};
                \node[draw=black, draw opacity=0.6] (A1) at (-0.6,1.4) {\stateAx\sone};
                \node[draw=black, draw opacity=0.6] (B0) at (0,0.8) {\stateEx\szero};
                \node[draw=black, draw opacity=0.6] (D0) at (0.6,0.2) {\stateDx\szero};

                % Fill 5 cells to the right of C1
                \foreach \i in {1,...,4} {
                        \node[minimum size=6mm, draw=none, fill=gray!20] at ($(C1)+(0.6*\i,0)$) {};
                    }



                \node[dashed, draw=red, thick] (red) at (1.2,2) {};

                \node (C1') at (1.2, -0.4) {\stateCx\sone};
                \node[draw=black, draw opacity=0.6] (A1') at (0.6, -1.0) {\stateAx\sone};
                \node[draw=black, draw opacity=0.6] (B0') at (1.2, -1.6) {\stateEx\szero};
                \node[draw=black, draw opacity=0.6] (D0') at (1.8, -2.2) {\stateDx\szero};

                % Fill 5 cells to the right of C1'
                \foreach \i in {1,...,4} {
                        \node[minimum size=6mm, draw=none, fill=gray!20] at ($(C1')+(0.6*\i,0)$) {};
                    }

                \node[dashed, draw=red, thick] (red') at (2.4,-0.4) {};

                \node[dashed] (C1'') at (2.4,-2.8) {\stateCx?};

                \draw[dashed, draw=red, thick] (red.south) -- (C1'.north);
                \draw[dashed, draw=red, thick] (red'.south) -- (C1''.north);

                \node[draw=none] at ($(red.north east)+(0.6,0.3)+(0.2,0.05)$) {$\overline{p_0}$};
                \draw[-{Latex[length=1.8mm]}] ($(red.north east)+(0.6,0.3)$) -- ($(red.north east)-(-0.05,0.00)$);

                \node[draw=none] at ($(red'.north east)+(0.6,0.3)+(0.2,0.05)$) {$\overline{p_0'}$};
                \draw[-{Latex[length=1.8mm]}] ($(red'.north east)+(0.6,0.3)$) -- ($(red'.north east)-(-0.05,0.00)$);

                % Arrow and label for p_1
                \node[draw=none] at ($(C1.north east)+(0.6,0.3)+(0.2,0.05)$) {$p_0$};
                \draw[-{Latex[length=1.8mm]}] ($(C1.north east)+(0.6,0.3)$) -- ($(C1.north east)-(-0.05,0.00)$);

                \node[draw=none] at ($(C1'.north east)+(0.6,0.3)+(0.2,0.05)$) {$p_0'$};
                \draw[-{Latex[length=1.8mm]}] ($(C1'.north east)+(0.6,0.3)$) -- ($(C1'.north east)-(-0.05,0.00)$);

                \node[draw=none] at ($(C1''.north east)+(0.6,0.3)+(0.2,0.05)$) {$p$};
                \draw[-{Latex[length=1.8mm]}] ($(C1''.north east)+(0.6,0.3)$) -- ($(C1''.north east)-(-0.05,0.00)$);


                % Eye to the right of C1
                % Stylized eye to the right of C1
                % \begin{scope}
                %     \coordinate (eyeC1) at ($(C1.east)+(0.3,0)$);
                %     \draw[thick] (eyeC1) ellipse (0.2 and 0.1);
                %     \fill ($(eyeC1)+(0.06,0)$) circle (0.035);

                %     % Eyelashes (relative to the top arc)
                %     \draw[thick] ($(eyeC1)+(0.0,0.1)$) -- ++(0,0.08);
                %     \draw[thick] ($(eyeC1)+(-0.08,0.08)$) -- ++(-0.05,0.06);
                %     \draw[thick] ($(eyeC1)+(0.08,0.08)$) -- ++(0.05,0.06);
                % \end{scope}

                % \begin{scope}
                %     \coordinate (eyeC1') at ($(C1'.east)+(0.3,0)$);
                %     \draw[thick] (eyeC1') ellipse (0.2 and 0.1);
                %     \fill ($(eyeC1')+(0.06,0)$) circle (0.035);

                %     % Eyelashes (same structure)
                %     \draw[thick] ($(eyeC1')+(0.0,0.1)$) -- ++(0,0.08);
                %     \draw[thick] ($(eyeC1')+(-0.08,0.08)$) -- ++(-0.05,0.06);
                %     \draw[thick] ($(eyeC1')+(0.08,0.08)$) -- ++(0.05,0.06);
                % \end{scope}


            \end{tikzpicture}
        }
    \end{minipage}
    \caption{TODO}\label{fig:loop-proof}
\end{figure}

\begin{theorem} Let $\mathcal{M}$ be a Turing machine.
    Assume there is $t_0' > t_0 \in \N$ such that
    for all $0 \leq i < t_0'-t_0$: $$f(p_i) = f(p'_i)$$ with $p_i = (t_0+i, g(t_0+i))$ and $p_i' = (t_0'+i, g(t_0'+i))$. Then, three cases:
    \begin{enumerate}
        \item If $g(t_0') = g(t_0)$, then $\mathcal{M}$ is a loop, more specifically called a \textit{Cycler}.\label{th:case1}
        \item If $g(t_0') \geq g(t_0)$ and the tape content to the right of $p_0$ is the same as to right of $p_0'$, \ie $\forall z \geq 0 \in  \Z \; f(t_0,g(t_0)+z) = f(t_0',g(t_0')+z)$, then $\mathcal{M}$ is a loop, more specifically called a (positive) \textit{Translated Cycler}.\label{th:case2}
        \item If $g(t_0') \leq g(t_0)$ and the tape content to the left of $p_0$ is the same as to left of $p_0'$, \ie $\forall z \leq 0 \in \Z \; f(t_0,g(t_0)+z) = f(t_0',g(t_0')+z)$, then $\mathcal{M}$ is a loop, more specifically called a (negative) \textit{Translated Cycler}.\label{th:case3}
    \end{enumerate}
    In these three cases the period of the loop is $l = t_0' - t_0$ and the pre-period is $t_0$ and $\mathcal{M}$ does not halt.
\end{theorem}

\begin{proof}



    Consider $p = (t, g(t))$ with $t=t_0'+l$ which corresponds to one time step after $p'_{l-1}$. Since $f(p_{l-1}) = f(p_{l-1}')$ we know that the same transition was taken at times $t_0+l-1$ and $t_0'+l-1$, hence $f(p)$ has the same state than $f(p'_0)$ and we also get that $p-p_{l-1}' = p_0' - p_{l-1}'$ which, using Lemma~\ref{lem:vector}, gives $p-p_0' = p'_0 - p_0$. Figure~\ref{fig:loop-proof} illustrates the situation for the theorem's cases~\ref{th:case1} (on the left) and~\ref{th:case2} (on the right): $p$ is the coordinates of the black dashed cell.

    We show that the read symbol at $p$ and $p'_0$ are also the same, \ie $f(p) = f(p'_0)$, three cases:

    \begin{enumerate}
        \item Case $g(t_0') = g(t_0)$, illustrated in Figure~\ref{fig:loop-proof}~(left). Since $p-p_0' = p'_0 - p_0$ and that $g(t_0') = g(t_0)$, the space component of $p-p_0'$ is 0 and we have that $g(t) = g(t_0')$. Hence, we know that the cell at tape position $g(t)$ has been visited at least one between time steps $t_0'$ and $t_0'+l-1$, which, by Lemma~\ref{lem:past} implies that the head's read symbol at times $t_0'$ and $t = t_0'+l$ is the same, giving $f(p) = f(p'_0)$.

        \item Case $g(t_0') \geq g(t_0)$, illustrated in Figure~\ref{fig:loop-proof}~(right). If there is a time step between $t_0'$ and $t_0'+l-1$ such that tape position $g(t)$ has been visited, we get that the head's read symbol at times $t$ and $t_0'$ is the same by Lemma~\ref{lem:past} implies, giving $f(p) = f(p'_0)$.

              Let's assume there is no such time step, which implies that $f(p) = f(\overline{p_0'})$ with $\overline{p_0'} = (t_0',g(t))$, dashed red in Figure~\ref{fig:loop-proof}~(right). It also implies that there is no time step between $t_0$ and $t_0+l-1$ such that tape position $g(t_0')$ has been visited, otherwise, our hypothesis would be contradicted by translating by $p_0'-p_0$. Hence, we also get $f(p'_0) = f(\overline{p_0})$ with $\overline{p_0} = (t_0,g(t_0'))$. By hypothesis, tape content to the right of $p_0$ is the same as to the right of $p_0'$, and $p-p_0' = p'_0 - p_0$ implies that $g(t)-g(t_0') = g(t_0') - g(t_0)$, hence $f(\overline{p_0}) = f(\overline{p_0'})$ and, finally, $f(p) = f(p'_0)$.\label{thm:proof:pt2}
        \item Case $g(t_0') \leq g(t_0)$, handled symmetrically to~\ref{thm:proof:pt2}.
    \end{enumerate}
    From there, since $f(p) = f(p'_0)$, the argument can be repeated starting with $p_1,\, \dots,\, p_{l-1},\, p'_0$ acting as new $p_0,\,\dots,\,p_{l-1}$ and $p'_1,\, \dots,\, p_{l-1}',\, p$ as new $p_0',\,\dots,\,p_{l-1}'$ by noting that for cases~\ref{th:case2} and~\ref{th:case3}, the fact that the tape is the same after $p_0$ and $p_0'$ implies that it is also the same after $p_1$ and $p_1'$. Hence, inductively, $\mathcal{M}$ is a loop and, by Lemma~\ref{lem:loopdonthalt}, it does not halt.
\end{proof}




\newpage

% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=0.4\textwidth]{figures/space-time-diagrams/cycler_279081.pdf}
%     \hspace{2ex}
%     \includegraphics[width=0.4\textwidth]{figures/space-time-diagrams/translated_cycler_62645534.pdf}
%     %\includegraphics[width=0.4\textwidth]{figures/space-time-diagrams/translated_cycler_59090563_2.png}
%     \caption{Space-time diagrams of the 30 first steps of a \textit{\cycler}\protect\footnotemark  with colors indicating head position and state: \stateA, \stateB, \stateC, \stateD, \stateE (left) and of the 10,000 first steps of a \textit{\TC}\protect\footnotemark (right). \cyclers are machines that eventually repeat the same configuration forever. \TCs are machines that eventually repeats the same configuration forever, but translated in space. We refer to these two types of machines as \textit{loops}.}\label{fig:loops}
% \end{figure}

% \footnotetext{\url{https://bbchallenge.org/1RB---\_0RC0LE\_1LD0LA\_1LB1RB\_1LC1RC}}
% \footnotetext{\url{https://bbchallenge.org/1RB0RE\_0LC1RC\_0RD1LA\_1LE---\_1LB1RC}}

% The goal of this decider is to recognise two types of Turing machines: (i) \textit{\cyclers} (see Figure~\ref{fig:loops}~left) that eventually repeat the same configuration and therefore loop forever and (ii) \textit{\TCs} that also eventually repeat the same configuration, but translated in space (see Figure~\ref{fig:loops}~right). We regroup both types of machines under the umbrella term of \textit{loops}.

% Deciding Cyclers reduces to the well-known mathematical problem of detecting the cycles of a function and standard detection algorithms exist \cite{wiki:Cycle_detection}, the simplest one consisting in memorizing each successive configuration of the machine until encountering one that has been already seen. Translated Cyclers, also known as \textit{Lin's recurrence}, have first been described and decided in Shen Lin's 1963 PhD thesis \cite{Lin1963}, other algorithms to detect them have been developed since then\footnote{\url{https://discuss.bbchallenge.org/t/decider-translated-cyclers/34}}.

% Here, we develop a new algorithm (Algorithm~\ref{alg:loops}) for deciding both \cyclers and \TCs. The particularity of this algorithm is that it detects loops only by analysing the history of state, read-symbol and \headposs visited by the machine, instead of considering entire configurations (\ie with full tape content information).

% Let's call the \textit{transcript} of a machine the list of successive \ssps visited by the machine from the all-zero tape. For instance, the transcript of the \cycler in Figure~\ref{fig:loops}~(left) starts with \texttt{A0 B0 C0 D0 B1 E0 C0 D0 B0 C1 A0} and the transcript of the \TC in Figure~\ref{fig:loops}~(right) starts with \texttt{A0 B0 C0 A0 B1 D1 C1 E0 C0 A1 C1}. Surprisingly, it turns out that in order to detect loops, we only have to track when a transcript repeats the same sequence twice back-to-back, for instance, in the case of the Cycler in Figure~\ref{fig:loops}: \texttt{A0 B0 C0 D0 B1 E0 C0 D0 B0 C1 A0 B0 C1 A0 B0 C1 A0 B0 C0 D0 \textbf{\underline{B1 E1 C0 D1}} \textbf{\underline{B1 E1 C0 D1}}}. When such a repetition occurs, we use the extra information of \headpos to conclude:

% \begin{itemize}
%     \item if when entering the second repetition the head is at the same position it was at the beginning of the first repetition, then we have detected a \cycler, \eg for the \cycler in Figure~\ref{fig:loops}~(left), here is the end of the transcript with extra head-position information given after each \ssp: \texttt{\underline{\textbf{B1(-2)} E1(-3) C0(-2) D1(-3)} \underline{\textbf{B1(-2)} E1(-3) C0(-2) D1(-3)}}.

%     \item if each time that the \headpos attains a local extremum (\ie a position that is strictly bigger or smaller than any previously seen position, also known as \textit{record-breaking}) in either repetition, it also corresponds to a local extremum in the other repetition, then we have detected a \TC, \eg for the \TC in Figure~\ref{fig:loops}~(right), the transcript (with \headpos information) is: \texttt{A0(0) \underline{B0(1)* C0(2)* A0(1) B1(2) D1(1) C1(2) E0(3)* C0(2) A1(1) C1(2) E1(3)} \\ \underline{B0(4)* C0(5)* A0(4) B1(5) D1(4) C1(5) E0(6)* C0(5) A1(4) C1(5) E1(6)}} etc., with all record-breaking positions marked \texttt{*} in the repeated \ssp pattern \texttt{B0 C0 A0 B1 D1 C1 E0 C0 A1 C1 E1}.

% \end{itemize}

% This logic is encoded in Algorithm~\ref{alg:loops}, l.\ref{alg:loops:test} and we prove that this algorithm is correct in Theorem~\ref{th:loops}.

% \begin{theorem}[Coq-BB5: \texttt{Lemma loop1\_decider\_WF}]\label{th:loops}
%     Let $\mathcal{M}$ be a Turing machine and $L \in \N^+$ a step-limit. \textsc{decider-loops}($\mathcal{M}$, $L$) terminates and its result is correct -- see Algorithm~\ref{alg:loops}:
%     \begin{itemize}
%         \item If the result is \texttt{HALT} then $\mathcal{M}$ halts from the all-zero tape.
%         \item If the result is \texttt{NONHALT} then $\mathcal{M}$ does not halt from the all-zero tape.
%     \end{itemize}
% \end{theorem}
% \begin{proof}
%     The call to \textsc{decider-loops}($\mathcal{M}$, $L$) terminates because of Algorithm~\ref{alg:loops}, l.\ref{alg:loops:terminate}. The call returns \texttt{HALT} if and only if $\mathcal{M}$ halts within $L$ steps from the all-zero tape, see Algorithm~\ref{alg:loops}, l.\ref{alg:loops:halt}, hence if the call returns \texttt{HALT} we know that the machine halts. The interesting case is the loop-detection leading to \texttt{NONHALT}. We leave this case as an exercise for the reader.

%     % We take the same terminology than Algorithm~\ref{alg:loops}: $h_i = (s_i,m_i,d_i) \in \states \times \alphabet \times \Z$ for $0 \leq i \leq L$ correspond the successive state, read-symbol and tape position reached. Let's assume the algorithm returns \texttt{NONHALT} for some loop length parameter $l \geq 0$: we have $s_{L-i} = s_{K-i}$ and $m_{L-i} = m_{K-i}$ for all $i \in [0,l]$ with $K = L-l-1$ and each $h_{L-i}$ is \textit{record-breaking} (\ie \headpos that is strictly bigger or smaller than any previously seen \headpos) iff $h_{K-i}$ is. Algorithm~\ref{alg:loops}, l.\ref{alg:loops:test} distinguishes two cases:

%     % \begin{enumerate}
%     %   \item $d_L$ is equal to $d_K$. In that case, let's show that $h_{L+1}$ is defined and that $h_{L+1} = h_{K+1}$. Because $s_K = s_L$ and $m_K = m_L$, the machine is in same state and reads same symbol at steps $K$ and $L$, hence the same transition is applied to go from $h_K$ to $h_{K+1}$ than from $h_L$ to $h_{L+1}$, meaning that $s_{L+1} = s_{K+1}$; furthermore, because $d_L = d_{K}$ we have $d_{L+1} = d_{K+1}$. Hence, $h_{L+1}$ is defined (\ie the machine has not halted), but it remains to prove that the read-symbol is the same, \ie $m_{L+1} = m_{K+1}$. First, let's notice than by the same argument we can conclude that $d_{L-i} = d_{K-i}$ for all $i \in [0,l]$. Then, let's consider $i_0 = \text{max}\{i \, | \, d_i = d_{K+1},\, i < L+1\}$. We know that $i_0$ is defined since $i_0 \geq K+1$. Piecing together what we know, we have that $h_{i_0} = h_{i_0 -l - 1}$ and therefore that $m_{L+1} = m_{K+1}$ since there is no step between $i_0$ and $L+1$ where position $d_{L+1}$ is reached, as well as no step between $i_0-l-1$ and $K+1$ where $d_{K+1} = d_{L+1}$ is reached, and the same transition was taken at $h_{i_0} = h_{i_0 -l - 1}$. Hence, $h_{L+1} = h_{K+1}$. Using this reasoning as induction step shows that, for all $i \in \N$ and $i' = i \text{ mod } l+1$, we have $h_{L+i} = h_{K+i'}$. The transcript of $\mathcal{M}$ is infinite, the machine does not halt from the all-zero tape.
%     %   \item $d_L$ is not equal to $d_K$ but \headpos records were broken. Let's slightly modify $h_i$ to be $h_i = (s_i,m_i,b_i) \in \states \times \alphabet \times \mathbb{B}$ where $b_i$ being \texttt{true} iff $d_i$ broke a record (\ie if for all $0 \geq j < i$ we have $d_j < d_i$). We know that $h_{L-i} = h_{K-i}$ for all $i \in [0,l]$. Let's show that $h_{L+1}$ is defined and that $h_{L+1} = h_{K+1}$. Similarly as in the first case, because $s_K = s_L$ and $m_K = m_L$ we know that $h_{L+1}$ is defined and $s_{L+1} = s_{K+1}$. Two cases:
%     %         \begin{itemize}
%     %           \item If $h_{K}$ and $h_{L}$ are record-breaking. If $h_{K+1}$ is record-breaking then so is $h_{L+1}$ because the head move direction is the same from $h_{K}$ to $h_{K+1}$ and $h_{L}$ to $h_{L+1}$. Hence, $m_{L+1} = m_{K+1} = 0$ and we have  $h_{L+1} = h_{K+1}$. If $h_{K+1}$ is not record-breaking, then $h_{L+1}$ is not record-breaking either again because head move directions are the same. In that case, because the cell at position $d_{L+1}$ has already been seen, we can apply the same argument as in case 1 above ($d_L = d_K$) and conclude that $h_{L+1} = h_{K+1}$.
%     %           \item If $h_{K}$ and $h_{L}$ are not record-breaking. If $h_{K+1}$ is record-breaking then so is $h_{L+1}$. \ts{TS: TO FINISH}
%     %         \end{itemize}


%     % \end{enumerate}

% \end{proof}


% \begin{algorithm}
%     \caption{{\sc decider-Loops}, reformulates the algorithm \texttt{loop1\_decider} of Coq-BB5.}\label{alg:loops}

%     \begin{algorithmic}[1]
%         \State{\textbf{Input:} A Turing machine `$\mathcal{M}$', a step-limit parameter $L$.}
%         \State{\textbf{Output:} `NONHALT' if the decider detects that the machine is a loop, `HALT' if the machine halts and \UNKNOWN otherwise.}

%         \State
%         \State Simulate $\mathcal{M}$ for $L$ steps and save the history of each consecutive state, read-symbol and tape position reached, \ie consecutive $h_i = (s_i,m_i,d_i)\in\states\times\alphabet\times\Z$ for $0 \leq i \leq L$ and $h_0 = (\stateA,\symbolzero,0)$.


%         \State \If{the machine has halted before $L$ steps}
%         \State \Return HALT \label{alg:loops:halt}
%         \EndIf
%         \State \For{$l$ \textbf{in} $[0,+\infty[$ } \Comment{$l+1$ is the length of the potential loop}
%         \State \If{$2(l + 1) > L$} \Comment{The history does not contain two potential loops of size $l+1$}
%         \State \Return UNKNOWN \label{alg:loops:terminate}
%         \State \EndIf
%         \State $K = L-l-1$
%         \State $\text{allequal} = \text{true}$
%         \State $\text{recordbreak} = \text{false}$
%         \State \For{$i$ \textbf{in} $[0,l]$ } \Comment{Comparing \ssp equality at each step of both potential loops}
%         \State $s,m,d = h_{L-i}$
%         \State $s',m',d' = h_{K-i}$
%         \State
%         \State $\text{recordbreak1} = \text{false}$
%         \State $\text{recordbreak2} = \text{false}$
%         \State \If{$s\neq s'$ \textbf{or} $m \neq m'$}
%         \State $\text{allequal} = \text{false}$
%         \State \textbf{break}
%         \EndIf
%         \State \If{$d > \text{max} \{d_j \, | \, j < L-i \}$ \textbf{or} $d < \text{min} \{d_j \, | \, j < L-i \}$}
%         \State $\text{recordbreak1} = \text{true}$
%         \State $\text{recordbreak} = \text{true}$
%         \EndIf
%         \State \If{$d' > \text{max} \{d'_j \, | \, j < K-i \}$ \textbf{or} $d' < \text{min} \{d'_j \, | \, j < K-i \}$}
%         \State $\text{recordbreak2} = \text{true}$
%         \EndIf
%         \State \If{$\text{recordbreak1} \neq \text{recordbreak2}$}
%         \State $\text{allequal} = \text{false}$
%         \State \textbf{break}
%         \EndIf
%         \EndFor
%         \State \If{$\text{allequal}$ \textbf{and} ($d_L == d_K$ \textbf{or} $\text{recordbreak}$)}\label{alg:loops:test}
%         \State \Return NONHALT
%         \EndIf
%         \EndFor

%     \end{algorithmic}

% \end{algorithm}

% \include{sections/decider-0-loop-results}